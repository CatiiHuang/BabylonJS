{"version":3,"file":"touchButton3D.js","sourceRoot":"","sources":["../../../../sourceES6/gui/src/3D/controls/touchButton3D.ts"],"names":[],"mappings":"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","sourcesContent":["// Assumptions: absolute position of button mesh is inside the mesh\r\n\r\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { PointerEventTypes } from \"@babylonjs/core/Events/pointerEvents\";\r\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { TmpVectors } from \"@babylonjs/core/Maths/math.vector\";\r\n\r\nimport { Button3D } from \"./button3D\";\r\n\r\n/**\r\n * Class used to create a touchable button in 3D\r\n */\r\nexport class TouchButton3D extends Button3D {\r\n    private _collisionMesh: Mesh;\r\n\r\n    // 'front' direction. If Vector3.Zero, there is no front and all directions of interaction are accepted\r\n    private _collidableFrontDirection: Vector3;\r\n    protected _isNearPressed = false;\r\n\r\n    /**\r\n     * Creates a new touchable button\r\n     * @param name defines the control name\r\n     * @param collisionMesh mesh to track collisions with\r\n     */\r\n    constructor(name?: string, collisionMesh?: Mesh) {\r\n        super(name);\r\n\r\n        this.collidableFrontDirection = Vector3.Zero();\r\n\r\n        if (collisionMesh) {\r\n            this.collisionMesh = collisionMesh;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the front-facing direction of the button. Pass in Vector3.Zero to allow interactions from any direction\r\n     * @param frontDir the forward direction of the button\r\n     */\r\n    public set collidableFrontDirection(frontWorldDir: Vector3) {\r\n        this._collidableFrontDirection = frontWorldDir.normalize();\r\n\r\n        if (this._collisionMesh) {\r\n            const invert = TmpVectors.Matrix[0];\r\n\r\n            invert.copyFrom(this._collisionMesh.getWorldMatrix());\r\n            invert.invert();\r\n            Vector3.TransformNormalToRef(this._collidableFrontDirection, invert, this._collidableFrontDirection);\r\n            this._collidableFrontDirection.normalize();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the front-facing direction of the button, or Vector3.Zero if there is no 'front'\r\n     */\r\n    public get collidableFrontDirection() {\r\n        if (this._collisionMesh) {\r\n            // Update the front direction to reflect any rotations of the collision mesh\r\n            const transformedDirection = TmpVectors.Vector3[0];\r\n            Vector3.TransformNormalToRef(this._collidableFrontDirection, this._collisionMesh.getWorldMatrix(), transformedDirection);\r\n\r\n            return transformedDirection.normalize();\r\n        }\r\n\r\n        return this._collidableFrontDirection;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh used for testing input collision\r\n     * @param collisionMesh the new collision mesh for the button\r\n     */\r\n    public set collisionMesh(collisionMesh: Mesh) {\r\n        if (this._collisionMesh) {\r\n            this._collisionMesh.dispose();\r\n        }\r\n\r\n        // parent the mesh to sync transforms\r\n        if (!collisionMesh.parent && this.mesh) {\r\n            collisionMesh.setParent(this.mesh);\r\n        }\r\n\r\n        this._collisionMesh = collisionMesh;\r\n        this._injectGUI3DReservedDataStore(this._collisionMesh).control = this;\r\n        this._collisionMesh.isNearPickable = true;\r\n\r\n        this.collidableFrontDirection = collisionMesh.forward;\r\n    }\r\n\r\n    // Returns true if the collidable is in front of the button, or if the button has no front direction\r\n    private _isInteractionInFrontOfButton(collidablePos: Vector3) {\r\n        return this._getInteractionHeight(collidablePos, this._collisionMesh.getAbsolutePosition()) > 0;\r\n    }\r\n\r\n    // Returns true if the collidable is in front of the button, or if the button has no front direction\r\n    protected _getInteractionHeight(interactionPos: Vector3, basePos: Vector3) {\r\n        const frontDir = this.collidableFrontDirection;\r\n        if (frontDir.length() === 0) {\r\n            // The button has no front, just return the distance to the base\r\n            return Vector3.Distance(interactionPos, basePos);\r\n        }\r\n        const d = Vector3.Dot(basePos, frontDir);\r\n        const abc = Vector3.Dot(interactionPos, frontDir);\r\n\r\n        return abc - d;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _generatePointerEventType(providedType: number, nearMeshPosition: Vector3, activeInteractionCount: number): number {\r\n        if (providedType === PointerEventTypes.POINTERDOWN) {\r\n            if (!this._isInteractionInFrontOfButton(nearMeshPosition)) {\r\n                // Near interaction mesh is behind the button, don't send a pointer down\r\n                return PointerEventTypes.POINTERMOVE;\r\n            }\r\n            else {\r\n                this._isNearPressed = true;\r\n            }\r\n        }\r\n        if (providedType === PointerEventTypes.POINTERUP) {\r\n            if (activeInteractionCount == 0) {\r\n                // We get the release for the down we swallowed earlier, swallow as well\r\n                return PointerEventTypes.POINTERMOVE;\r\n            }\r\n            else {\r\n                this._isNearPressed = false;\r\n            }\r\n        }\r\n\r\n        return providedType;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"TouchButton3D\";\r\n    }\r\n\r\n    // Mesh association\r\n    protected _createNode(scene: Scene): TransformNode {\r\n        return super._createNode(scene);\r\n    }\r\n\r\n    /**\r\n     * Releases all associated resources\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n\r\n        if (this._collisionMesh) {\r\n            this._collisionMesh.dispose();\r\n        }\r\n    }\r\n}"]}