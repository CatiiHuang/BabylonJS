{"version":3,"file":"codeStringParsingTools.js","sourceRoot":"","sources":["../../../sourceES6/core/Misc/codeStringParsingTools.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Helpers to parse code strings\r\n */\r\nexport class CodeStringParsingTools {\r\n\r\n    /**\r\n     * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\r\n     * @param markerOpen opening marker\r\n     * @param markerClose closing marker\r\n     * @param block code block to parse\r\n     * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\r\n     * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\r\n     */\r\n    public static ExtractBetweenMarkers(markerOpen: string, markerClose: string, block: string, startIndex: number): number {\r\n        let currPos = startIndex,\r\n            openMarkers = 0,\r\n            waitForChar = '';\r\n\r\n        while (currPos < block.length) {\r\n            let currChar = block.charAt(currPos);\r\n\r\n            if (!waitForChar) {\r\n                switch (currChar) {\r\n                    case markerOpen:\r\n                        openMarkers++;\r\n                        break;\r\n                    case markerClose:\r\n                        openMarkers--;\r\n                        break;\r\n                    case '\"':\r\n                    case \"'\":\r\n                    case \"`\":\r\n                        waitForChar = currChar;\r\n                        break;\r\n                    case '/':\r\n                        if (currPos + 1 < block.length) {\r\n                            const nextChar = block.charAt(currPos + 1);\r\n                            if (nextChar === '/') {\r\n                                waitForChar = '\\n';\r\n                            } else if (nextChar === '*') {\r\n                                waitForChar = '*/';\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n            } else {\r\n                if (currChar === waitForChar) {\r\n                    if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                        block.charAt(currPos - 1) !== '\\\\' && (waitForChar = '');\r\n                    } else {\r\n                        waitForChar = '';\r\n                    }\r\n                } else if (waitForChar === '*/' && currChar === '*' && currPos + 1 < block.length) {\r\n                    block.charAt(currPos + 1) === '/' && (waitForChar = '');\r\n                    if (waitForChar === '') {\r\n                        currPos++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            currPos++;\r\n            if (openMarkers === 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return openMarkers === 0 ? currPos - 1 : -1;\r\n    }\r\n\r\n    /**\r\n     * Parses a string and skip whitespaces\r\n     * @param s string to parse\r\n     * @param index index where to start parsing\r\n     * @returns the index after all whitespaces have been skipped\r\n     */\r\n    public static SkipWhitespaces(s: string, index: number): number {\r\n        while (index < s.length) {\r\n            const c = s[index];\r\n            if (c !== ' ' && c !== '\\n' && c !== '\\r' && c !== '\\t' && c !== '\\u000a' && c !== '\\u00a0') {\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\r\n     * @param c character to check\r\n     * @returns true if the character is an identifier character\r\n     */\r\n    public static IsIdentifierChar(c: string): boolean {\r\n        const v = c.charCodeAt(0);\r\n        return (v >= 48 && v <= 57) || // 0-9\r\n            (v >= 65 && v <= 90) || // A-Z\r\n            (v >= 97 && v <= 122) || // a-z\r\n            (v == 95); // _\r\n    }\r\n\r\n    /**\r\n     * Removes the comments of a code block\r\n     * @param block code block to parse\r\n     * @returns block with the comments removed\r\n     */\r\n    public static RemoveComments(block: string): string {\r\n        let currPos = 0,\r\n            waitForChar = '',\r\n            inComments = false,\r\n            s = [];\r\n\r\n        while (currPos < block.length) {\r\n            let currChar = block.charAt(currPos);\r\n\r\n            if (!waitForChar) {\r\n                switch (currChar) {\r\n                    case '\"':\r\n                    case \"'\":\r\n                    case \"`\":\r\n                        waitForChar = currChar;\r\n                        break;\r\n                    case '/':\r\n                        if (currPos + 1 < block.length) {\r\n                            const nextChar = block.charAt(currPos + 1);\r\n                            if (nextChar === '/') {\r\n                                waitForChar = '\\n';\r\n                                inComments = true;\r\n                            } else if (nextChar === '*') {\r\n                                waitForChar = '*/';\r\n                                inComments = true;\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n                if (!inComments) {\r\n                    s.push(currChar);\r\n                }\r\n            } else {\r\n                if (currChar === waitForChar) {\r\n                    if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                        block.charAt(currPos - 1) !== '\\\\' && (waitForChar = '');\r\n                        s.push(currChar);\r\n                    } else {\r\n                        waitForChar = '';\r\n                        inComments = false;\r\n                    }\r\n                } else if (waitForChar === '*/' && currChar === '*' && currPos + 1 < block.length) {\r\n                    block.charAt(currPos + 1) === '/' && (waitForChar = '');\r\n                    if (waitForChar === '') {\r\n                        inComments = false;\r\n                        currPos++;\r\n                    }\r\n                } else {\r\n                    if (!inComments) {\r\n                        s.push(currChar);\r\n                    }\r\n                }\r\n            }\r\n\r\n            currPos++;\r\n        }\r\n\r\n        return s.join('');\r\n    }\r\n\r\n    /**\r\n     * Finds the first occurrence of a character in a string going backward\r\n     * @param s the string to parse\r\n     * @param index starting index in the string\r\n     * @param c the character to find\r\n     * @returns the index of the character if found, else -1\r\n     */\r\n    public static FindBackward(s: string, index: number, c: string): number {\r\n        while (index >= 0 && s.charAt(index) !== c) {\r\n            index--;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Escapes a string so that it is usable as a regular expression\r\n     * @param s string to escape\r\n     * @returns escaped string\r\n     */\r\n    public static EscapeRegExp(s: string): string {\r\n        return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n    }\r\n\r\n}\r\n"]}