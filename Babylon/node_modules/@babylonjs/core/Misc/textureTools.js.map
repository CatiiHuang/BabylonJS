{"version":3,"file":"textureTools.js","sourceRoot":"","sources":["../../../sourceES6/core/Misc/textureTools.ts"],"names":[],"mappings":"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","sourcesContent":["import { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\n\r\nimport { Scene } from \"../scene\";\r\nimport { PostProcess } from '../PostProcesses/postProcess';\r\nimport { Engine } from '../Engines/engine';\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport class TextureTools {\r\n    /**\r\n     * Uses the GPU to create a copy texture rescaled at a given size\r\n     * @param texture Texture to copy from\r\n     * @param width defines the desired width\r\n     * @param height defines the desired height\r\n     * @param useBilinearMode defines if bilinear mode has to be used\r\n     * @return the generated texture\r\n     */\r\n    public static CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode: boolean = true): Texture {\r\n\r\n        var scene = <Scene>texture.getScene();\r\n        var engine = scene.getEngine();\r\n\r\n        let rtt = new RenderTargetTexture(\r\n            'resized' + texture.name,\r\n            { width: width, height: height },\r\n            scene,\r\n            !texture.noMipmap,\r\n            true,\r\n            (<InternalTexture>texture._texture).type,\r\n            false,\r\n            texture.samplingMode,\r\n            false\r\n        );\r\n\r\n        rtt.wrapU = texture.wrapU;\r\n        rtt.wrapV = texture.wrapV;\r\n        rtt.uOffset = texture.uOffset;\r\n        rtt.vOffset = texture.vOffset;\r\n        rtt.uScale = texture.uScale;\r\n        rtt.vScale = texture.vScale;\r\n        rtt.uAng = texture.uAng;\r\n        rtt.vAng = texture.vAng;\r\n        rtt.wAng = texture.wAng;\r\n        rtt.coordinatesIndex = texture.coordinatesIndex;\r\n        rtt.level = texture.level;\r\n        rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\r\n        (<InternalTexture>rtt._texture).isReady = false;\r\n\r\n        texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        let passPostProcess = new PassPostProcess(\"pass\", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);\r\n        passPostProcess.getEffect().executeWhenCompiled(() => {\r\n            passPostProcess.onApply = function (effect) {\r\n                effect.setTexture(\"textureSampler\", texture);\r\n            };\r\n\r\n            let internalTexture = rtt.renderTarget;\r\n\r\n            if (internalTexture) {\r\n                scene.postProcessManager.directRender([passPostProcess], internalTexture);\r\n\r\n                engine.unBindFramebuffer(internalTexture);\r\n                rtt.disposeFramebufferObjects();\r\n                passPostProcess.dispose();\r\n\r\n                rtt.getInternalTexture()!.isReady = true;\r\n            }\r\n        });\r\n\r\n        return rtt;\r\n    }\r\n\r\n    /**\r\n     * Apply a post process to a texture\r\n     * @param postProcessName name of the fragment post process\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param type type of the output texture. If not provided, use the one from internalTexture\r\n     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n     * @param format format of the output texture. If not provided, use the one from internalTexture\r\n     * @return a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    public static ApplyPostProcess(postProcessName: string, internalTexture: InternalTexture, scene: Scene, type?: number, samplingMode?: number, format?: number): Promise<InternalTexture> {\r\n        // Gets everything ready.\r\n        const engine = internalTexture.getEngine() as Engine;\r\n\r\n        internalTexture.isReady = false;\r\n\r\n        samplingMode = samplingMode ?? internalTexture.samplingMode;\r\n        type = type ?? internalTexture.type;\r\n        format = format ?? internalTexture.format;\r\n\r\n        if (type === -1) {\r\n            type = 0;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            // Create the post process\r\n            const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine,\r\n                false, undefined, type, undefined, null, false, format);\r\n\r\n            // Hold the output of the decoding.\r\n            const encodedTexture = engine.createRenderTargetTexture({ width: internalTexture.width, height: internalTexture.height }, {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode,\r\n                type,\r\n                format\r\n            });\r\n\r\n            postProcess.getEffect().executeWhenCompiled(() => {\r\n                // PP Render Pass\r\n                postProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", internalTexture);\r\n                    effect.setFloat2(\"scale\", 1, 1);\r\n                };\r\n                scene.postProcessManager.directRender([postProcess!], encodedTexture, true);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                engine._releaseTexture(internalTexture);\r\n                if (postProcess) {\r\n                    postProcess.dispose();\r\n                }\r\n\r\n                // Internal Swap\r\n                encodedTexture._swapAndDie(internalTexture);\r\n\r\n                // Ready to get rolling again.\r\n                internalTexture.type = type!;\r\n                internalTexture.format = 5;\r\n                internalTexture.isReady = true;\r\n\r\n                resolve(internalTexture);\r\n            });\r\n        });\r\n    }\r\n\r\n    // ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\r\n    private static _FloatView: Float32Array;\r\n    private static _Int32View: Int32Array;\r\n    /**\r\n     * Converts a number to half float\r\n     * @param value number to convert\r\n     * @returns converted number\r\n     */\r\n    public static ToHalfFloat(value: number): number {\r\n        if (!TextureTools._FloatView) {\r\n            TextureTools._FloatView = new Float32Array(1);\r\n            TextureTools._Int32View = new Int32Array(TextureTools._FloatView.buffer);\r\n        }\r\n\r\n        TextureTools._FloatView[0] = value;\r\n        const x = TextureTools._Int32View[0];\r\n\r\n        let bits = (x >> 16) & 0x8000; /* Get the sign */\r\n        let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\r\n        const e = (x >> 23) & 0xff; /* Using int is faster here */\r\n\r\n        /* If zero, or denormal, or exponent underflows too much for a denormal\r\n        * half, return signed zero. */\r\n        if (e < 103) {\r\n            return bits;\r\n        }\r\n\r\n        /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\r\n        if (e > 142) {\r\n            bits |= 0x7c00;\r\n            /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n            * not Inf, so make sure we set one mantissa bit too. */\r\n            bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);\r\n            return bits;\r\n        }\r\n\r\n        /* If exponent underflows but not too much, return a denormal */\r\n        if (e < 113) {\r\n            m |= 0x0800;\r\n            /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n            * to 1, which is OK. */\r\n            bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\r\n            return bits;\r\n        }\r\n\r\n        bits |= ((e - 112) << 10) | (m >> 1);\r\n        bits += m & 1;\r\n        return bits;\r\n    }\r\n\r\n    /**\r\n     * Converts a half float to a number\r\n     * @param value half float to convert\r\n     * @returns converted half float\r\n     */\r\n    public static FromHalfFloat(value: number): number {\r\n        const s = (value & 0x8000) >> 15;\r\n        const e = (value & 0x7C00) >> 10;\r\n        const f = value & 0x03FF;\r\n\r\n        if (e === 0) {\r\n            return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n        } else if (e == 0x1F) {\r\n            return f ? NaN : ((s ? -1 : 1) * Infinity);\r\n        }\r\n\r\n        return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + (f / Math.pow(2, 10)));\r\n    }\r\n}\r\n"]}