{"version":3,"file":"geodesicBuilder.js","sourceRoot":"","sources":["../../../../sourceES6/core/Meshes/Builders/geodesicBuilder.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,iBAAiB,EAAE,MAAM,qBAAqB,CAAC;AAExD,OAAO,EAAE,MAAM,EAAE,MAAM,mBAAmB,CAAC;AAC3C,OAAO,EAAE,mBAAmB,EAAE,YAAY,EAAE,MAAM,iBAAiB,CAAC;AAEpE;;GAEG;AACF;IAAA;IA6DA,CAAC;IA5DE;;;;;;;;;;;;;;;;;;;;OAoBG;IACW,8BAAc,GAA5B,UAA6B,IAAY,EAAE,OAAmP,EAAE,KAA6B;QAA7B,sBAAA,EAAA,YAA6B;QACzT,IAAI,CAAC,GAAW,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC;QAC/B,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;YACrB,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACpB,MAAM,CAAC,IAAI,CAAC,qCAAqC,CAAC,CAAC;SACtD;QACD,IAAI,CAAC,GAAW,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC;QAC/B,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;YACrB,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACpB,MAAM,CAAC,IAAI,CAAC,qCAAqC,CAAC,CAAC;SACtD;QACD,IAAI,CAAC,GAAG,CAAC,EAAE;YACP,IAAM,IAAI,GAAG,CAAC,CAAC;YACf,CAAC,GAAG,CAAC,CAAC;YACN,CAAC,GAAG,IAAI,CAAC;YACT,MAAM,CAAC,IAAI,CAAC,iCAAiC,CAAC,CAAC;SAClD;QACD,IAAM,OAAO,GAAwB,IAAI,mBAAmB,EAAE,CAAC;QAC/D,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACpB,IAAM,YAAY,GAAG,YAAY,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QAE7D,IAAM,UAAU,GAAW;YACvB,MAAM,EAAE,YAAY;YACpB,IAAI,EAAE,OAAO,CAAC,IAAI;YAClB,KAAK,EAAE,OAAO,CAAC,KAAK;YACpB,KAAK,EAAE,OAAO,CAAC,KAAK;YACpB,KAAK,EAAE,OAAO,CAAC,KAAK;YACpB,MAAM,EAAE,OAAO,CAAC,MAAM;YACtB,UAAU,EAAE,OAAO,CAAC,UAAU;YAC9B,IAAI,EAAE,OAAO,CAAC,IAAI;YAClB,SAAS,EAAE,OAAO,CAAC,SAAS;YAC5B,eAAe,EAAE,OAAO,CAAC,eAAe;YACxC,QAAQ,EAAE,OAAO,CAAC,QAAQ;YAC1B,OAAO,EAAE,OAAO,CAAC,OAAO;SAC3B,CAAC;QACF,IAAM,QAAQ,GAAG,iBAAiB,CAAC,gBAAgB,CAAC,IAAI,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;QAE7E,OAAO,QAAQ,CAAC;IACpB,CAAC;IACJ,sBAAC;AAAD,CAAC,AA7DD,IA6DC","sourcesContent":["import { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { PolyhedronBuilder } from \"./polyhedronBuilder\";\r\nimport { Nullable } from '../../types';\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh\";\r\n\r\n/**\r\n * Class containing static functions to help procedurally build a geodesic mesh\r\n */\r\n export class GeodesicBuilder {\r\n    /**\r\n     * Creates the Mesh for a Geodesic Polyhedron\r\n     * @see https://en.wikipedia.org/wiki/Geodesic_polyhedron\r\n     * @param name defines the name of the mesh\r\n     * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n     * * m number of horizontal steps along an isogrid\r\n     * * n number of angled steps along an isogrid\r\n     * * size the size of the Geodesic, optional default 1\r\n     * * sizeX allows stretching in the x direction, optional, default size\r\n     * * sizeY allows stretching in the y direction, optional, default size\r\n     * * sizeZ allows stretching in the z direction, optional, default size\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param scene defines the hosting scene\r\n     * @returns Geodesic mesh\r\n     */\r\n    public static CreateGeodesic(name: string, options: { m?: number, n?: number, size?: number, sizeX?: number, sizeY?: number, sizeZ?: number, faceUV?: Vector4[], faceColors?: Color4[], flat?: boolean, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }, scene: Nullable<Scene> = null): Mesh {\r\n        let m: number = options.m || 1;\r\n        if (m !== Math.floor(m)) {\r\n            m === Math.floor(m);\r\n            Logger.Warn(\"m not an integer only floor(m) used\");\r\n        }\r\n        let n: number = options.n || 0;\r\n        if (n !== Math.floor(n)) {\r\n            n === Math.floor(n);\r\n            Logger.Warn(\"n not an integer only floor(n) used\");\r\n        }\r\n        if (n > m) {\r\n            const temp = n;\r\n            n = m;\r\n            m = temp;\r\n            Logger.Warn(\"n > m therefore m and n swapped\");\r\n        }\r\n        const primTri: _PrimaryIsoTriangle = new _PrimaryIsoTriangle();\r\n        primTri.build(m, n);\r\n        const geodesicData = GeodesicData.BuildGeodesicData(primTri);\r\n\r\n        const geoOptions: object = {\r\n            custom: geodesicData,\r\n            size: options.size,\r\n            sizeX: options.sizeX,\r\n            sizeY: options.sizeY,\r\n            sizeZ: options.sizeZ,\r\n            faceUV: options.faceUV,\r\n            faceColors: options.faceColors,\r\n            flat: options.flat,\r\n            updatable: options.updatable,\r\n            sideOrientation: options.sideOrientation,\r\n            frontUVs: options.frontUVs,\r\n            backUVs: options.backUVs\r\n        };\r\n        const geodesic = PolyhedronBuilder.CreatePolyhedron(name, geoOptions, scene);\r\n\r\n        return geodesic;\r\n    }\r\n }"]}