import { __assign } from "tslib";
import { InternalTexture, InternalTextureSource } from "../../../Materials/Textures/internalTexture";
import { RenderTargetCreationOptions } from "../../../Materials/Textures/renderTargetCreationOptions";
import { RenderTargetWrapper } from "../../renderTargetWrapper";
import { WebGPUEngine } from "../../webgpuEngine";
WebGPUEngine.prototype._createHardwareRenderTargetWrapper = function (isMulti, isCube, size) {
    var rtWrapper = new RenderTargetWrapper(isMulti, isCube, size, this);
    this._renderTargetWrapperCache.push(rtWrapper);
    return rtWrapper;
};
WebGPUEngine.prototype.createRenderTargetTexture = function (size, options) {
    var _a, _b;
    var rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);
    var fullOptions = new RenderTargetCreationOptions();
    if (options !== undefined && typeof options === "object") {
        fullOptions.generateMipMaps = options.generateMipMaps;
        fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;
        fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;
        fullOptions.type = options.type === undefined ? 0 : options.type;
        fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;
        fullOptions.format = options.format === undefined ? 5 : options.format;
        fullOptions.samples = (_a = options.samples) !== null && _a !== void 0 ? _a : 1;
        fullOptions.creationFlags = (_b = options.creationFlags) !== null && _b !== void 0 ? _b : 0;
    }
    else {
        fullOptions.generateMipMaps = options;
        fullOptions.generateDepthBuffer = true;
        fullOptions.generateStencilBuffer = false;
        fullOptions.type = 0;
        fullOptions.samplingMode = 3;
        fullOptions.format = 5;
        fullOptions.samples = 1;
        fullOptions.creationFlags = 0;
    }
    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
        fullOptions.samplingMode = 1;
    }
    else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
        fullOptions.samplingMode = 1;
    }
    var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
    var width = size.width || size;
    var height = size.height || size;
    var layers = size.layers || 0;
    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.depth = layers;
    texture.isReady = true;
    texture.samples = fullOptions.samples;
    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    texture.format = fullOptions.format;
    texture.is2DArray = layers > 0;
    texture._cachedWrapU = 0;
    texture._cachedWrapV = 0;
    this._internalTexturesCache.push(texture);
    rtWrapper.setTextures(texture);
    if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {
        rtWrapper.createDepthStencilTexture(0, fullOptions.samplingMode === undefined ||
            fullOptions.samplingMode === 2 || fullOptions.samplingMode === 2 ||
            fullOptions.samplingMode === 3 || fullOptions.samplingMode === 3 ||
            fullOptions.samplingMode === 5 || fullOptions.samplingMode === 6 ||
            fullOptions.samplingMode === 7 || fullOptions.samplingMode === 11, rtWrapper._generateStencilBuffer, rtWrapper.samples);
    }
    if (options !== undefined && typeof options === "object" && options.createMipMaps && !fullOptions.generateMipMaps) {
        texture.generateMipMaps = true;
    }
    this._textureHelper.createGPUTextureForInternalTexture(texture, undefined, undefined, undefined, fullOptions.creationFlags);
    if (options !== undefined && typeof options === "object" && options.createMipMaps && !fullOptions.generateMipMaps) {
        texture.generateMipMaps = false;
    }
    return rtWrapper;
};
WebGPUEngine.prototype._createDepthStencilTexture = function (size, options, rtWrapper) {
    var internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);
    var internalOptions = __assign({ bilinearFiltering: false, comparisonFunction: 0, generateStencil: false, samples: 1, depthTextureFormat: 15 }, options);
    // TODO WebGPU We set the format to Depth32 if depthTextureFormat=Depth16 because Chrome does not support Depth16 yet
    internalTexture.format =
        internalOptions.generateStencil ? 13 :
            internalOptions.depthTextureFormat === 15 ? 14 : internalOptions.depthTextureFormat;
    this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);
    this._textureHelper.createGPUTextureForInternalTexture(internalTexture);
    this._internalTexturesCache.push(internalTexture);
    return internalTexture;
};
WebGPUEngine.prototype._setupDepthStencilTexture = function (internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction, samples) {
    if (samples === void 0) { samples = 1; }
    var width = size.width || size;
    var height = size.height || size;
    var layers = size.layers || 0;
    internalTexture.baseWidth = width;
    internalTexture.baseHeight = height;
    internalTexture.width = width;
    internalTexture.height = height;
    internalTexture.is2DArray = layers > 0;
    internalTexture.depth = layers;
    internalTexture.isReady = true;
    internalTexture.samples = samples;
    internalTexture.generateMipMaps = false;
    internalTexture.samplingMode = bilinearFiltering ? 2 : 1;
    internalTexture.type = 1;
    internalTexture._comparisonFunction = comparisonFunction;
    internalTexture._cachedWrapU = 0;
    internalTexture._cachedWrapV = 0;
};
WebGPUEngine.prototype.updateRenderTargetTextureSampleCount = function (rtWrapper, samples) {
    if (!rtWrapper || !rtWrapper.texture || rtWrapper.samples === samples) {
        return samples;
    }
    samples = Math.min(samples, this.getCaps().maxMSAASamples);
    if (samples > 1) {
        // TODO WEBGPU for the time being, Chrome only accepts values of 1 or 4
        samples = 4;
    }
    this._textureHelper.createMSAATexture(rtWrapper.texture, samples);
    if (rtWrapper._depthStencilTexture) {
        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);
        rtWrapper._depthStencilTexture.samples = samples;
    }
    rtWrapper.texture.samples = samples;
    return samples;
};
//# sourceMappingURL=engine.renderTarget.js.map