{"version":3,"file":"objFileLoader.js","sourceRoot":"","sources":["../../../sourceES6/loaders/src/OBJ/objFileLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"@babylonjs/core/types\";\nimport { Vector2 } from \"@babylonjs/core/Maths/math.vector\";\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\nimport { SceneLoader, ISceneLoaderPluginAsync, ISceneLoaderProgressEvent, ISceneLoaderPluginFactory, ISceneLoaderPlugin, ISceneLoaderAsyncResult } from \"@babylonjs/core/Loading/sceneLoader\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer\";\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { WebRequest } from '@babylonjs/core/Misc/webRequest';\nimport { MTLFileLoader } from './mtlFileLoader';\nimport { OBJLoadingOptions } from \"./objLoadingOptions\";\nimport { SolidParser } from \"./solidParser\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\n\n/**\n * OBJ file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class OBJFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\n\n    /**\n     * Defines if UVs are optimized by default during load.\n     */\n    public static OPTIMIZE_WITH_UV = true;\n    /**\n     * Invert model on y-axis (does a model scaling inversion)\n     */\n    public static INVERT_Y = false;\n    /**\n     * Invert Y-Axis of referenced textures on load\n     */\n    public static get INVERT_TEXTURE_Y() {\n        return MTLFileLoader.INVERT_TEXTURE_Y;\n    }\n\n    public static set INVERT_TEXTURE_Y(value: boolean) {\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\n    }\n\n    /**\n     * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\n     */\n    public static IMPORT_VERTEX_COLORS = false;\n    /**\n     * Compute the normals for the model, even if normals are present in the file.\n     */\n    public static COMPUTE_NORMALS = false;\n    /**\n     * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\n     * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\n     */\n    public static OPTIMIZE_NORMALS = false;\n    /**\n     * Defines custom scaling of UV coordinates of loaded meshes.\n     */\n    public static UV_SCALING = new Vector2(1, 1);\n    /**\n     * Skip loading the materials even if defined in the OBJ file (materials are ignored).\n     */\n    public static SKIP_MATERIALS = false;\n\n    /**\n     * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\n     *\n     * Defaults to true for backwards compatibility.\n     */\n    public static MATERIAL_LOADING_FAILS_SILENTLY = true;\n    /**\n     * Defines the name of the plugin.\n     */\n    public name = \"obj\";\n    /**\n     * Defines the extension the plugin is able to load.\n     */\n    public extensions = \".obj\";\n\n    private _assetContainer: Nullable<AssetContainer> = null;\n\n    private _loadingOptions: OBJLoadingOptions;\n\n    /**\n     * Creates loader for .OBJ files\n     *\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\n     */\n    constructor(loadingOptions?: OBJLoadingOptions) {\n        this._loadingOptions = loadingOptions || OBJFileLoader.DefaultLoadingOptions;\n    }\n\n    private static get DefaultLoadingOptions(): OBJLoadingOptions {\n        return {\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\n            invertY: OBJFileLoader.INVERT_Y,\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\n            UVScaling: OBJFileLoader.UV_SCALING,\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS\n        };\n    }\n\n    /**\n     * Calls synchronously the MTL file attached to this obj.\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\n     * Without this function materials are not displayed in the first frame (but displayed after).\n     * In consequence it is impossible to get material information in your HTML file\n     *\n     * @param url The URL of the MTL file\n     * @param rootUrl defines where to load data from\n     * @param onSuccess Callback function to be called when the MTL file is loaded\n     */\n    private _loadMTL(url: string, rootUrl: string, onSuccess: (response: string | ArrayBuffer, responseUrl?: string) => any, onFailure: (pathOfFile: string, exception?: any) => void) {\n        //The complete path to the mtl file\n        var pathOfFile = rootUrl + url;\n\n        // Loads through the babylon tools to allow fileInput search.\n        Tools.LoadFile(\n            pathOfFile,\n            onSuccess,\n            undefined,\n            undefined,\n            false,\n            (request?: WebRequest | undefined, exception?: any) => {\n                onFailure(pathOfFile, exception);\n            }\n        );\n    }\n\n    /**\n     * Instantiates a OBJ file loader plugin.\n     * @returns the created plugin\n     */\n    createPlugin(): ISceneLoaderPluginAsync | ISceneLoaderPlugin {\n        return new OBJFileLoader(OBJFileLoader.DefaultLoadingOptions);\n    }\n\n    /**\n     * If the data string can be loaded directly.\n     *\n     * @param data string containing the file data\n     * @returns if the data can be loaded directly\n     */\n    public canDirectLoad(data: string): boolean {\n        return false;\n    }\n\n    /**\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @param fileName Defines the name of the file to load\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\n     */\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<ISceneLoaderAsyncResult> {\n        //get the meshes from OBJ file\n        return this._parseSolid(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes: meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: []\n            };\n        });\n    }\n\n    /**\n     * Imports all objects from the loaded OBJ data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @param fileName Defines the name of the file to load\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    public loadAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\n        //Get the 3D model\n        return this.importMeshAsync(null, scene, data, rootUrl, onProgress).then(() => {\n            // return void\n        });\n    }\n\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @param onProgress The callback when the load progresses\n     * @param fileName Defines the name of the file to load\n     * @returns The loaded asset container\n     */\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer> {\n        var container = new AssetContainer(scene);\n        this._assetContainer = container;\n\n        return this.importMeshAsync(null, scene, data, rootUrl).then((result) => {\n            result.meshes.forEach((mesh) => container.meshes.push(mesh));\n            result.meshes.forEach((mesh) => {\n                var material = mesh.material;\n                if (material) {\n                    // Materials\n                    if (container.materials.indexOf(material) == -1) {\n                        container.materials.push(material);\n\n                        // Textures\n                        var textures = material.getActiveTextures();\n                        textures.forEach((t) => {\n                            if (container.textures.indexOf(t) == -1) {\n                                container.textures.push(t);\n                            }\n                        });\n                    }\n                }\n            });\n            this._assetContainer = null;\n            return container;\n        }).catch((ex) => {\n            this._assetContainer = null;\n            throw ex;\n        });\n    }\n\n    /**\n     * Read the OBJ file and create an Array of meshes.\n     * Each mesh contains all information given by the OBJ and the MTL file.\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene defines the scene where are displayed the data\n     * @param data defines the content of the obj file\n     * @param rootUrl defines the path to the folder\n     * @returns the list of loaded meshes\n     */\n    private _parseSolid(meshesNames: any, scene: Scene, data: string, rootUrl: string): Promise<Array<AbstractMesh>> {\n        var fileToLoad: string = \"\";      //The name of the mtlFile to load\n        var materialsFromMTLFile: MTLFileLoader = new MTLFileLoader();\n        var materialToUse = new Array<string>();\n        var babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\n\n        // Main function\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\n\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName: string) => {\n            fileToLoad = fileName;\n        });\n\n        // load the materials\n        let mtlPromises: Array<Promise<void>> = [];\n        // Check if we have a file to load\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\n            //Load the file synchronously\n            mtlPromises.push(new Promise((resolve, reject) => {\n                this._loadMTL(fileToLoad, rootUrl, (dataLoaded) => {\n                    try {\n                        //Create materials thanks MTLLoader function\n                        materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\n                        //Look at each material loaded in the mtl file\n                        for (var n = 0; n < materialsFromMTLFile.materials.length; n++) {\n                            //Three variables to get all meshes with the same material\n                            var startIndex = 0;\n                            var _indices = [];\n                            var _index;\n\n                            //The material from MTL file is used in the meshes loaded\n                            //Push the indice in an array\n                            //Check if the material is not used for another mesh\n                            while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                                _indices.push(_index);\n                                startIndex = _index + 1;\n                            }\n                            //If the material is not used dispose it\n                            if (_index === -1 && _indices.length === 0) {\n                                //If the material is not needed, remove it\n                                materialsFromMTLFile.materials[n].dispose();\n                            } else {\n                                for (var o = 0; o < _indices.length; o++) {\n                                    //Apply the material to the Mesh for each mesh with the material\n                                    const mesh = babylonMeshesArray[_indices[o]];\n                                    const material = materialsFromMTLFile.materials[n];\n                                    mesh.material = material;\n\n                                    if (!mesh.getTotalIndices()) {\n                                        // No indices, we need to turn on point cloud\n                                        material.pointsCloud = true;\n                                    }\n                                }\n                            }\n                        }\n                        resolve();\n                    } catch (e) {\n                        Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\n                        if (this._loadingOptions.materialLoadingFailsSilently) {\n                            resolve();\n                        } else {\n                            reject(e);\n                        }\n                    }\n                }, (pathOfFile: string, exception?: any) => {\n                    Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\n                    if (this._loadingOptions.materialLoadingFailsSilently) {\n                        resolve();\n                    } else {\n                        reject(exception);\n                    }\n                });\n            }));\n\n        }\n        //Return an array with all Mesh\n        return Promise.all(mtlPromises).then(() => {\n            return babylonMeshesArray;\n        });\n    }\n\n}\n\nif (SceneLoader) {\n    //Add this loader into the register plugin\n    SceneLoader.RegisterPlugin(new OBJFileLoader());\n}"]}